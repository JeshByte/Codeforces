The optimal strategy here would be to change a character only if both of its neighbours are equal to it or if its left neighbour is equal to it. We don't need to do it for the right neighbour because as we are traversing from left to right we will eventually reach this right neighbour and then we can make the changes accordingly. Otherwise there are chances of overlapping wasted operations. There is one edge case here where the last element will end up being ignored. So we need to check for it seperately. Also as there are only 26 letters, for each letter we can manually check for its appropriate replacement as other methods like incrementing it(which I had tried) can cause errors in some cases.
