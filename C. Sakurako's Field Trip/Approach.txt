In each operation we can swap an element with its mirror image. If we swap it again, we pretty much negate our previous operation. So for each pair we will perform the operation at most once. For an array of size n, we will have n/2 pairs. So for each pair we have the choice to swap it or not to minimise the disturbance as much as possible. Thus we can use dp here to check for all possibilities. So we define our state as dp[i][0/1] which shows the minimum disturbance for the first i pairs where 0 means we didn't swap the ith pair and 1 means we did swap it. So the transitions will be - 
1)dp[i][0]=min((dp[i-1][0]+(arr[i-1]==arr[i])+(arr[n-i-1]==arr[n-i])),(dp[i-1][1]+(arr[i]==arr[n-i])+(arr[n-i-1]==arr[i-1])))
2)dp[i][1]=min((dp[i-1][1]+(arr[i-1]==arr[i])+(arr[n-i-1]==arr[n-i])),(dp[i-1][0]+(arr[i]==arr[n-i])+(arr[n-i-1]==arr[i-1])))
As we are only dealing with the pairs, i will go till len=Ceil(n/2). Here there is an edge case when n is even as we don't check for any disturbance between arr[len-1] & arr[len]. So we will have to handle this seperately. The base case will be arr[0][0/1]=0 and the final subproblem will be min(arr[len-1][0],arr[len-1][1]).
