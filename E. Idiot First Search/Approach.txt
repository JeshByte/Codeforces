Here, if we dry run some traversals we will notice a pattern. When we start from a node, we traverse its entire child tree. Then we go to its parent. When it reaches its parent, the rest of the traversal is equivalent to just starting from the parent itself. So lets say I somehow calculate the downward movement of each node i and the answer for its parent then the answer for that node will be downward_moves[i]+ans[parent[i]]+1. The +1 is to account for the movement from the node to its parent. Now lets see how we can calculate the downward movement for all the nodes efficiently. We can do a dfs traversal where whenever we reach a node we initialise a counter moves. Then we traverse each of its children. For each child, we add 1(the movement into that child), another 1(the movement out of that child) and the moves counter returned by the child node itself. Then we return this moves counter to the parent node after storing it in a dp array. After we are done with the traversal, the dp array will have the downward movements of all the nodes. Then we have to do another dfs traversal, to calculate the final answer for each of the nodes using the above formula. We have to do this as per the order of the traversal to ensure that the parent's answer is calculated before the child, as we would need it to find the child's answer. In this way we can find the answer in linear time.
